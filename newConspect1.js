"use strict";

// Динамическая типизация в JS

console.log(typeof(5 + "")); // конкретинация - сложение строки с чем-то, другим типом данных, на выходе мы получаем строку.

console.log(typeof(+"5")); // унарный плюч динамический типизирует строку с число!

console.log(typeof(parseInt("15px", 10)));// динамическая типизация через методы чисел


let answer = +prompt("Hello", ""); // метод prompt возвращает данные от пользователя в виде строки, но с помощью унарного плюса, мы вернём от него данные в виде числа. Все данные получаемые от пользователя это строки! 


// to boolean

// 0, "", null, undefinde, NaN в логическом контексте эти все значения являются false!Пустая строка будет false именно пустая без пробелов!
// пустые массивы, объекты в логическом контексте это true 

let switcher = null;

if (switcher) {
    console.log("Working");// условие не выполниться так как switcher = false ! 
}

console.log(typeof(!!"5"));// два знака отрицая преобразуют строку в булиновое значение!

// Замыкание и лексическое окружение ======================================================
//  Любая переменная это свойство объекта лексического окружения

function createCounter () {
    let counter = 0;

    const myFunction = function () { // нам нужно запомнить то, что у функции есть доступ к переменным в вызвавшей её области. Формальное название такого феномена — область видимости.
        counter = counter + 1;
        return counter;
    };

    return myFunction;
}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();

console.log(c1, c2, c3);

function makeWorker() {
    let name = "Pete";
  
    return function() {
      console.log(name);
    };
  }
  
  let name = "John";
  
  // create a function
  let work = makeWorker();
  
  // call it
  console.log(work());
  console.log(work());

//   Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
//   Работа с переменными – это на самом деле работа со свойствами этого объекта.
//   Функция получает текущее значение внешних переменных, то есть их последнее значение

let nameJ = "John";

function sayHi() {
 console.log("Hi, " + nameJ);
}
sayHi();
nameJ = "Pete"; // (*)
sayHi();

// Один вызов – одно лексическое окружение
// Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

// И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

// Лексическое окружение – это специальный внутренний объект
// «Лексическое окружение» – это специальный внутренний объект. 
// Мы не можем получить его в нашем коде и изменять напрямую. 
// Сам движок JavaScript может оптимизировать его, 
// уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, 
// но видимое поведение объекта должно оставаться таким, как было описано.



// Замыкания
// В программировании есть общий термин: «замыкание», – которое должен знать каждый разработчик.

// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. 
// Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

// То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], 
// и все они могут получить доступ к внешним переменным.

// Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», 
// – правильным ответом будет определение замыкания и объяснения того факта, 
// что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: 
// свойстве [[Environment]] и о том, как работает лексическое окружение.

// Для цикла у каждой итерации своё отдельное лексическое окружение. 
// Если переменная объявлена в for(let ...), то она также в нём:


// let x = 5;
// console.log( x++ );// 5, правильно, постфиксная форма сначало вернёт x  а только потом присвоет х инкримент

// console.log([ ] + false - null + true);// NaN. Пустой массив это строка! Конечный результат NaN так как в дальше мы проводим математические действия с не математическимим значения, в результате чего получается NaN

// let y = 1; 
// let x = y = 2; 
// console.log(x); // 2 я ответил 1

console.log([ ] + 1 + 2); // "12" я ответил 3. Пустой массив это строка! Так как массив строка, дальше произошла конкратинация 

console.log("1"[0]); // выведет 1 , я не знал ответ. К каждому элементу строки можно обратится по его индексу ! 

console.log(2 && 1 && null && 0 && undefined);// null , правильно

console.log(a && b); // не знаю

console.log( null || 2 && 3 || 4 );// вывел 3, почему не знаю? Надо смотреть таблицу приоритетов операторов у && приоритет выше чем у ||

a = [1, 2, 3]; b = [1, 2, 3];// Правда ли что a == b ?//  нет не правда, так как эти две переменные это два разных массива в которых просто лежит одинаковая информация

console.log( +"Infinity");// вывведит инфинити, правильно

console.log("Ёжик">"Яюлоко");// рпавильно, любая строка с текстом или пробелами это в логическом контексте true

console.log(0 || "" || 2 || undefined || true || false );// вывел 2, правильно, потому что || оператор припинается на первом true 